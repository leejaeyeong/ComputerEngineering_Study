## Algorithm

### - Sort
  1. **Selection Sort**
   - 원리 :
  주어진 항목중에서 가장 작은 수를 찾고 가장 첫 번째 위치의 값과 교체한다. 첫 번째 위치에는 주어진 항목중에서 가장 작은 수가 저장되어 있으므로 첫 번째 위치를 제외하고 남은 항목에서 가장 작은 수를 찾아 다음 위치의 값교 교체한다. 이 과정을 배열의 크기 -1 만큼 반복한다.

  2. **Insertion Sort**
   - 원리 :
  1번 index부터 비교를 시작한다. 0번 index와 비교했을 때 1번 index가 작으면 두 값을 서로 교환한다. 그 다음 index의 값을 하위 index값과 비교하여 알맞은 위치에 값을 초기화하고 나머지 값들은 다음 index로 한 칸씩 밀어서 초기화한다. 이 과정을 배열의 크기 -1 만큼 반복한다.  
  3. **Bubble Sort**
   - 원리 :
  0번 index와 1번 index를 비교하여 작은 값을 비교하느 왼쪽 index의 값과 교체한 후 다음 1번 index와 2번 index를 비교하여 위 과정을 반복한다. 전체 배열에 대해서 한 번의 순회를 마치면 가장 큰 값은 배열의 맨 끝에 위치하게 된다. 이 값에 대해서는 비교를 할 필요가 없으므로 순회를 마칠 때마다 정렬된 index를 비교대상에서 제외시켜가면서 위 과정을 반복한다.

  4. **Merge Sort**
   - 원리 :
 주어진 배열을 배열의 길이가 1이 될때까지 분할한다. 분할 과정이 끝나면 다시 단계적으로 배열을 합치고 이때 작은 값은 왼쪽 index에 큰 값은 오른쪽 index에 위치시킨다. 다음 단계에서 두 배열을 합칠 때 각 배열의 index의 첫 번째 값을 비교하여순서대로 합친다. 만약 한쪽 합치려고하는 한 쪽 배열에 값이 존재하지 않으면 나머지배열을 그대로 합치려는 배열 끝에 저장한다.  

  5. **Quick Sort**
   - 원리 :
  주어진 배열에 기준을 설정하고 배열의 각 index의 값을 기준 index의 값과 비교하여 작으면 왼쪽 크면 오른쪽에 위치 시킨다. 1차로 정렬이 완료되면 기준의 왼쪽과 오른족이 섞일 일은 없으므로 왼쪽에 기준을 설정하여 반복하고 오른쪽에 기준을 설정하여 정렬이 될 때까지 반복한다.



### - Search
  1. **Graph**
   - Graph 탐색이란 한 정점에서 다른 정점을 차례대로 방문하면서 모든 정점을 한 번씩 방문하는 것을 말한다. 그래프를 탐색하는 방법으로 크게 DFS와 BFS가 있다.


  2. **Linear Search**
   - 선형 탐색은 데이터를 정렬할 필요 없이 순차적으로 하나 하나 비교하면서 원하는 값을 탐색하는 방법이다. 데이터의 처음 부터 끝까지 하나하나 비교하면서 진행하기 때문에 데이터가 많아지면 비효울적일 수 있다.
  **Linear Search의 예)** Linear Search의 예로는 식당에서 메뉴를 고를 때 하나 하나 비교해가면서 원하는 메뉴가 있을 때까지 순차적으로 탐색을 반복하는 것이다.


  3. **Binary Search**
   - 이진 탐색은 분할 정복의 예라고 할 수 있다. 임의의 기준 값을 정하고 찾는 값이 기준 값 보다 크면 기준 값을 기준으로 오른쪽에 기준 값을 새로 설정한 후 위 과정을 반복하여 값을 찾는다.
  **Binary Search의 예)** Binary Search의 예로는 500 페이지 짜리 책에서 375 페이지를 펴고 싶을 때 임의로 책일 편 후 페이지를 확인한다. 해당 페이지가 375 보다 크면 왼쪽에서 위 과정을 반복하고 375 보다 작으면 오른쪽에서 위 과정을 반복하는 것으로 원하는 375페이지를 찾을 수 있다.


  4. **Hash**  
   - **Hash Code의 생성**  
         우선 Hash의 생성은 Key  값을 입력하여  Hash 생성 알고리즘을 통해 Hash 코드를 생성한다.
   - **Hash Code의 탐색**  
  Hash Code 생성 알고리즘을 통해 생성된 Hash Code를 Key 값을 이용해 Hahs Table에서 찾아 찾고자하는 Hash Code 값을 찾는다.
   - **Hash의 특징**  
  Key 값을 통해 Hash Code 생성하는데 있어서 Key와 Hash Code는 제한이 없지만 이를 저장할 수 있는 Hash Table은 한정적이다. 따라서 다른 Hash Code일 지라도 Hash Table에 같은 index에 저장 될 수 있다. 따라서 좋은 Hash 생성 알고리즘은 생성된 Hash Code를 얼마나 골고루 Hash Table에 저장하는지가 중요하다.  
   - ex) 입력 받은 Key 문자열에서 각 아스키 값을 더해 해쉬코드를 생성하고 Hash 정보가 저장될 고정된 배열을 선언한다. 저장될 Hash Table의 위치는 [Hash Code % Hash Table의 배열 크기 ]로 계산한다고 가정하자.


    ---> Key 값으로 sung, jin, hee, min을 각각 입력하면 위 Hash 생성 알고리즘을 통해 445, 321, 306, 324라는 Hash Code가 생성된다.  
    
    s(115) + u(117) + n(110) + g(103) = 445

    j(106) + i(105) + n(110) = 321

    h(104) + e(101) + e(101) = 306

    m(109) + i(105) + n(110) = 324

    크기 3의 배열을 만들었다고 가정한 후 Hash Code가 저장될 위치를 계산하면 각각

    445 % 3 = 1

    321 % 3 = 0

    306 % 3 = 0

    324 % 3 = 0

    위 알고리즘을 통해 생성된 Hash Code의 위치는 그다지 고르게 생성된 것 같지 않다.(Hash Code가 주어진 배열에 고르게 분포하는 것이 처리 속도에 매우 중요함) 445, 321, 306, 324라는 Hash Code는 각각 arr[1], arr[0], arr[0], arr[0]에 저장될 것이다. 이러한 Hash Table에서 원하는 Key 값을 찾기 위해서는 arr[0]와 같이 Hash Code가 1개 이상으로 저장되는 경우에 기존에 저장되어 있던 Hash Code에 linkedlist에 데이터를 추가한다.

    결과적으로 원하는 Hash Code를 찾기 위해서는 Key 생성 알고리즘을 통해 Key로 Hash Code를 생성한 후 이를 index 값으로 변환하고 해당 index를 갖는 Hash Table을 돌면서 Key와 일치하는 Hash Code를 찾는 것이다.



  5. **DFS : Depth-first traversal** :  
  DFS란 깊이 우선 탐색을 말한다. 하나의 노드로 부터 Stack에 노드를 저장하면서 탐색을 시작하다가 인접한 노드가 2개 이상일 경우 한 가지 방향을 선택하여 계속해서 탐색한다. 인접한 노드를 모두 탐색한 경우 Stack에 저장된 값으로 가까운 갈림길로 돌아와 다른 방향으로 깊이 우선 탐색을 진행한다.
   - Stack을 이용하여 DFS 구현 : 우선 Stack을 만들고 시작 노드를 Stack에 push한다. Stack에 있는 노드를 pop하고 노드의 child 노드를 스택에 push한다. (단, 한 번 Stack에 넣었던 노드는 다시 넣지 않아야한다.) 계속해서 Stack에 있는 노드를 pop하고 꺼낸 노드의 자식 노드를 Stack에 push한다.(Child 노드가 없을 경우 Stack에 있는 다음 노드를 pop하고 반복한다) 이 과정을 반복하여 Graph의 DFS를 구현 할 수 있다.

  6. **BFS : Breadth-first traversal** :  
  BFS란 너비 우선 탐색을 말한다. BFS와는 다르게 갈림길을 만날 경우 한 방향으로 끝까지 탐색하고 돌아오는 것이 아니라 인접한 노드부터 탐색을 진행한다. Queue를 이용하여 구현할 수있다.
   - Queue를 이용하여 BFS 구현 : Queue를 만들고 시작 노드를 Queue에 넣는다. Queue에 있는 노드를 pop하고 pop한 노드의 child 노드를 push한다. (이때 한 번 push한 노드는 다시 push하지 않는다.) 이어서 Queue에 있는 노드를 pop하고 pop한 노드의 child 노드를 push한다. 이 과정을 반복하여 Graph의 BFS를 구현 할 수 있다.



### - String Match
  1. **Java String**
- Java에서 String을 입력 받는 방법은 두 가지가 있다. 첫 번째는 <code>String text1=" ";</code>와 같이 String 자료형에 변수를 선언하는 방법이고 두 번째는 <code>String text2 = new Sting(" ");</code>와 같이 new 키워들 통한 새로운 객체를 생성하는 방법이다.
  이 두 방식을 literal, 생성자를 이용한 방식이라고 한다. String을 선언하는 두 가지 방식의 차이는 String 선언 시 저장되는 메모리의 차이이다. 생성자를 통해 String을 생성하면 Heap 영역에 존재하게 되고 literal을 이용할 경우 string constant pool이라는 영역에 존재하게 된다.
  이런 저장되는 메모리의 차이는 예상하지 못한 결과를 가져올 수 있다. 예를들어 서로 다른 방식으로 선언된 문자열에 대해 == 연산을 할 경우 String에 저장된 내용은 동일하더라도 결과는 flase를 반환한다. 왜냐하면 == 연산은 메모리의 주소값을 비교하기 때문이다. text1과 text2 literal과 생성자로 서로 다른 방식으로 선언되었기 때문에 각각 메모리의 Heap 영역과 String constant pool 영역에 저장되었기 때문에 다른 주소값을 참조함으로 false를 반환한다. 결과적으로 두 문자열의 변수에 같은 문자열이 저장되어 있는지 확인하고 싶을 때는 <code>text1.equals(text2);</code> 와 같이 사용한다.

  2. **KMP**
- **KMP 알고리즘은 문자열 A와 문자열 B가 있을 때 문자열 A에서 문자열 B를 찾아주는 알고리즘이다.**
가장 기본적인 문자열 탐색 알고리즘은 한 자리 한 자리를 비교해가면서 문자열이 일치하는 지 검사하는 방법이다. 이 방법은 불필요한 비교를 반복하기 때문에 비효율적이다. 그러나 KMP 알고리즘을 사용하면 이런 불필요한 비교를 하지 않고 문자열을 찾을 수 있다.
**KMP 알고리즘의 예)** ABCDABCDABE라는 문자열에서 ABCDABE라는 문자열을 찾는다고 하면 비교하는 0번째 문자열에서 5번째 문자열 까지는 같지만 6번째 문자열이 다르므로 찾는 문자열이 아니다. KMP가 아닌 다른 알고리즘은 그 다음 index인 1번 째 문자열에서 다시 비교를 하지만 KMP 알고리즘은 접두사와 접미사를 이용하여 비교 당하는 문자열의 접미사와 비교하는 문자열의 접두사가 일치하는 4번째 위치부터 비교를 시작하여 훨씬 빠르게 원하는 문자열을 찾을 수 있는 것이다.


### - Greedy  
  1. **Greedy 알고리즘이란?**  
- Greedy 알고리즘이란 프로그램이 연산하는 각 단계에서 최적의 선택을 하는 알고리즘이다. Greedy 알고리즘은 해당 단계에서 최적의 선택을 하고 그 선택을 바탕으로 답을 도출한다. 이것은 전체적인 문제에 대한 답이 아니라 부분적인 문제에 대해 최적의 선택을 통해 도출한 답이기 때문에 전체적인 문제의 최적의 해와 다를 수 있다. Greedy 알리즘은 모든 데이터를 검사하지않고 최적의 데이터만 다루므로 연산속도가 빠르다는 장점이 있지만 Greedy 알고리즘을 통해 도출한 답과 전체적인 문제에 대한 최적의 답이 다를 경우에는 사용할 수 없다. 따라서 Greedy 알고리즘을 적용하기 전에 전체적인 최적의 해인지를 항상 염두할 필요가 있다.


  2. **Greedy 알고리즘의 부분적인 해가 최적의 해가 아닌 예)**
- 10원, 7원, 1원짜리 동전이 있을 때 최소의 동전 개수로 거스름돈을 주는 프로그램을 Greedy 알고리즘으로 설계한다면 ?
---> Greedy 알고리즘은 매 순간의 최적의 선택을 하기 때문에 거슬러 줘야 할 금액에 대해 가장 먼저 10원짜리 동전으로 거스름돈을 얼마나 지불할 수 있는지에 대해 판단할 것이다. 그 다음 두 번째로 큰 7원으로 거스름돈을 얼마나 지불할 수 있을지 판단하고 다음으로 1원으로 판단할 것이다. 그런데 만약 거스름돈으로 14원을 지불해야하는 상황이라면 위 알고리즘을 통해 10원짜리 동전 1개, 1원 짜리 동전 4개를 지불할 것이다. 하지만 최소의 동전 갯수로 거스름을 지불하는 방법은 7원짜리 동전 2개로 지불하는 방법이다. 결과적으로 Greedy 알고리즘을 통해 도출한 답은 전체적인 최적의 답이 아닐수도 있기 때문에 알고리즘을 적용하기 전에 판단을 잘 해야한다.  


### - Divide & Conquer
  1. Divide & Conquer 알고리즘이란?
- **Divide & Conquer 알고리즘이란 한 번에 해결하기 어려운 문제를 분할한 후 처리하여 부분적인 답을 도출하고 이를 종합하여 전체의 답을 구하는 알고리즘 이다.**
예를들어 Quick Sort의 경우도 Divide & Conquer라고 할 수 있다. Quick Sort를 할 때에는 peek 값을 정하고 peek값을 기준으로 작은 수는 왼쪽, 큰 수는 오른쪽으로 정렬한 다음 왼쪽 또는 오른쪽에 peek 값을 새로 설정하여 위 과정을 반복한다. 재귀를 통해 부분적으로 문제를 해결하다보면 결국 전체적인 문제가 해결된다는 것이 Divide & Conquer 알고리즘이다.  
